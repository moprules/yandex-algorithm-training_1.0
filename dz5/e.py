"""
E. Красота превыше всего

В парке города Питсбурга есть чудесная аллея, состоящая из N посаженных в один
ряд деревьев, каждое одного из K сортов. В связи с тем, что Питсбург принимает
открытый чемпионат Байтландии по программированию, было решено построить
огромную арену для проведения соревнований. Так, согласно этому плану вся аллея
подлежала вырубке. Однако министерство деревьев и кустов воспротивилось этому
решению, и потребовало оставить некоторые из деревьев в покое. Согласно новому
плану строительства все деревья, которые не будут вырублены, должны образовывать
один непрерывный отрезок, являющийся подотрезком исходного. Каждого из K видов
деревьев требуется сохранить хотя бы по одному экземпляру. На вас возложена
задача найти отрезок наименьшей длины, удовлетворяющий указанным ограничениям.

Формат ввода
В первой строке входного файла находятся два числа N и K (1 <= N, K <= 250000).
Во второй строке входного файла следуют N чисел (разделенных пробелами),
i-ое число второй строки задает цвет i-ого слева дерева в аллее. Гарантируется,
что присутствует хотя бы одно дерево каждого цвета.

Формат вывода
В выходной файл выведите два числа, координаты левого и правого концов отрезка
минимальной длины, удовлетворяющего условию. Если оптимальных ответов несколько,
выведите любой.

Пример 1
Ввод
5 3
1 2 1 3 2
Вывод
2 4

Пример 2
Ввод
6 4
2 4 2 3 3 1
Вывод
2 6
"""


def input_data():
    n, k = map(int, input().split())
    trees = [int(color) for color in input().split()]
    return n, trees, k


def solve(n, trees, k):
    # Так как во всем массиве точно найдётся послеждовательность деревьев
    # удовлетворяющая условию, то по умолчанию за ответ возмём концы этого массива
    # Длина такого отрезка будет максимальной
    # потом если получиться мы будем его менять
    best_left = 0
    best_right = n-1
    # массивчик для подсчёта деревьев определённоо цвета
    # Цвета деревьев начинаются с 1, для удобства пусть
    # у нас будет 0 элемент, в который ничего не будет записываться,
    # зато избежим опечаток и ошибок на 1
    colors = [0] * (k+1)
    # счётчик уникальных цветов в отрезке деревьев
    cnt_uniq = 0
    # Изначально левый указатель ставим в самое начало
    left = 0
    for right, color in enumerate(trees):
        # Если такие цвета еще не встречались
        if not colors[color]:
            # Увеличиваем счётчик уникальных цветов
            cnt_uniq += 1
        # увеличиваем счётчик деревьев такого цвета
        colors[color] += 1

        # Если количество уникальных цветов деревьев равно k
        if cnt_uniq == k:
            # Сдваигаем левый указатель до тех пор пока его
            # пока количество деревьев с таким цветом как
            # на этой позициине станет = 1
            while colors[trees[left]] > 1:
                colors[trees[left]] -= 1
                left += 1

            # Если длина реультирующего минимального (лучшего) отрезка
            # Больше текущего, то лучший отрезок - это текущий
            if best_right - best_left > right - left:
                best_right = right
                best_left = left

    return (best_left + 1, best_right + 1)


if __name__ == "__main__":
    n, d, r = input_data()
    res = solve(n, d, r)
    print(*res)
